#pragma once
#include <string>
#include <vector>
#include <map>
#include <tuple>

class TeamMaker{
  public:
    //constructor taking in the teammate percentage data and individual usage percentage data
    TeamMaker(const std::string& teamFile, const std::string& usageFile);
  
    //parser for teammates data set, return a vector of tuple containing Pokemon name, 
    //map of teammate and its percentage, and viability ceiling
    std::vector<std::tuple<std::string, std::map<std::string, double>, double>> teammatesParser(const std::string& fileName);
  
    //parser for usage data set, returns a map of Pokemon name and its usage percentage
    std::vector<double> usageParser(const std::string& fileName, unsigned size);
  
    //destructor
    ~TeamMaker();
  
    //dfs for finding whether a pokemon is connected to another one or not, if not, then the team sucks
    bool dfs(unsigned start, unsigned key);
  
    //floyd warshall for finding the weight between each pokemon
    void floydWarshall();
  
    //the function for generating the team, taking in a string of pokemon names separated by comma and space
    //use helper function pokemonsToVector to turn the string of pokemons into a vector of pokemons
    std::vector<std::string> generateTeam(const std::string& pokemons);
    
//   private:
    //map mapping pokemon with its index
    std::map<std::string, unsigned> index_;

    //vector of pokemon names in index order
    std::vector<std::string> mons_;
  
    //vector of its usage percentage, with index representing a pokemon
    std::vector<double> usage_;
  
    //vector representing map of index of pokemon and its teammates percentage
    std::vector<std::map<unsigned, double>> teammates_;
  
    //vector representing the viability ceiling of each pokemon
    std::vector<double> viability_;
  
    //2d vector of weights generated by floyd warshall
    std::vector<std::vector<double>> weights_;
  
    //helper function for generateTeam for turning a string of pokemon names to a vector of pokemons
    std::vector<unsigned> pokemonsToVector(const std::string& str);
};

class graph {
public: 
std::vector<std::vector<std::string>> all_pokemon_with_neighbor;
std::map<std::string, std::vector<std::string>> adjList; 

graph(TeamMaker* teammate, const std::string& pokemons) {
std::vector<std::string> team = teammate->generateTeam(pokemons);
// std::vector<std::vector<std::string>> all_pokemon_with_neighbor;
std::vector<std::string> pokemon_with_neighbor;
// used to get the neighbors for the pokemons in the team. 
// first, get the index of the pokemon from index[pokemon], then do teammates[index] to get a map of the neighbours 
// create the 2d vector that holds the pokemon and its neighbors
for(unsigned int i = 0; i < team.size(); i++) {
    std::string current_pokemon = team.at(i);
    pokemon_with_neighbor.push_back(current_pokemon);
    // how to find the neighbor 
    // run through a loop, then push it back to pokemon_with_neighbor
    auto currIdx = teammate->index_[current_pokemon];
    auto neighbors = teammate->teammates_[currIdx];
    // for(int j =0 ; j < neighbor.size();j++) {
    //   pokemon_with_neighbor.push_back(neighbor.at(j));
    // }
      for(auto x : neighbors) {
          pokemon_with_neighbor.push_back(teammate->mons_[x.first]);
      }
      all_pokemon_with_neighbor.push_back(pokemon_with_neighbor);
  // push pokemon_with_neightbor into al_pokemon_with_neighbor
      pokemon_with_neighbor.clear();
      }
    

for (unsigned i = 0; i < all_pokemon_with_neighbor.size(); i++) {
  std::vector<std::string> temp; 
  for (unsigned j = 1; j < all_pokemon_with_neighbor.at(i).size(); j++) {
    // first thing in the row is the key ,the rest are being oushed into a vector
    temp.push_back(all_pokemon_with_neighbor[i][j]);
  }
  // add into the map
  adjList[all_pokemon_with_neighbor[i][0]] = temp;
}
}
};
